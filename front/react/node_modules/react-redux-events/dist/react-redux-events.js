(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ReactReduxEvents"] = factory();
	else
		root["ReactReduxEvents"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(4);


/***/ }),
/* 1 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	// Internal / Debug Use
	var REDUX_EVENT = exports.REDUX_EVENT = '@@__REDUX_EVENT';
	var SET_LOGLEVEL = exports.SET_LOGLEVEL = '@@__REDUX_EVENT__SET_LOGLEVEL';

	// External Use
	var DISPATCH_EVENT = exports.DISPATCH_EVENT = '@@__REDUX_EVENT__DISPATCH_EVENT';
	var ADD_EVENT_LISTENER = exports.ADD_EVENT_LISTENER = '@@__REDUX_EVENT__ADD_EVENT_LISTENER';
	var REMOVE_EVENT_LISTENER = exports.REMOVE_EVENT_LISTENER = '@@__REDUX_EVENT__REMOVE_EVENT_LISTENER';
	var REMOVE_ALL_LISTENERS_FOR_EVENT = exports.REMOVE_ALL_LISTENERS_FOR_EVENT = '@@__REDUX_EVENT__REMOVE_ALL_LISTENERS_FOR_EVENT';
	var REMOVE_ALL_LISTENERS_FOR_CONTEXT = exports.REMOVE_ALL_LISTENERS_FOR_CONTEXT = '@@__REDUX_EVENT__REMOVE_ALL_LISTENERS_FOR_CONTEXT';

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _constants = __webpack_require__(1);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ReduxEvent = function ReduxEvent(name) {
	  var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	  _classCallCheck(this, ReduxEvent);

	  this.__event_type = _constants.REDUX_EVENT;
	  this.name = name;
	  this.payload = payload;
	  this.priority = priority;
	};

	exports['default'] = ReduxEvent;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.setLogLevel = exports.removeAllListenersForEvent = exports.removeAllListenersForContext = exports.removeEventListener = exports.addEventListener = exports.dispatchEvent = undefined;

	var _constants = __webpack_require__(1);

	var dispatchEvent = exports.dispatchEvent = function dispatchEvent(event) {
	  return {
	    type: _constants.DISPATCH_EVENT,
	    event: event
	  };
	};

	var addEventListener = exports.addEventListener = function addEventListener(name, context, handler) {
	  var priority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	  return {
	    type: _constants.ADD_EVENT_LISTENER,
	    name: name,
	    context: context,
	    handler: handler,
	    priority: priority
	  };
	};

	var removeEventListener = exports.removeEventListener = function removeEventListener(name, context, handler) {
	  return {
	    type: _constants.REMOVE_EVENT_LISTENER,
	    context: context,
	    name: name,
	    handler: handler
	  };
	};

	var removeAllListenersForContext = exports.removeAllListenersForContext = function removeAllListenersForContext(context) {
	  return {
	    type: _constants.REMOVE_ALL_LISTENERS_FOR_CONTEXT,
	    context: context
	  };
	};

	var removeAllListenersForEvent = exports.removeAllListenersForEvent = function removeAllListenersForEvent(name) {
	  return {
	    type: _constants.REMOVE_ALL_LISTENERS_FOR_EVENT,
	    name: name
	  };
	};

	var setLogLevel = exports.setLogLevel = function setLogLevel(level) {
	  return {
	    type: _constants.SET_LOGLEVEL,
	    level: level
	  };
	};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.setLogLevel = exports.removeAllListenersForContext = exports.removeAllListenersForEvent = exports.removeEventListener = exports.addEventListener = exports.dispatchEvent = exports.reduxEventReducer = exports.ReduxEvent = undefined;

	var _actions = __webpack_require__(3);

	var _reducer = __webpack_require__(5);

	var _reducer2 = _interopRequireDefault(_reducer);

	var _ReduxEvent = __webpack_require__(2);

	var _ReduxEvent2 = _interopRequireDefault(_ReduxEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	exports.ReduxEvent = _ReduxEvent2['default'];
	exports.reduxEventReducer = _reducer2['default'];
	exports.dispatchEvent = _actions.dispatchEvent;
	exports.addEventListener = _actions.addEventListener;
	exports.removeEventListener = _actions.removeEventListener;
	exports.removeAllListenersForEvent = _actions.removeAllListenersForEvent;
	exports.removeAllListenersForContext = _actions.removeAllListenersForContext;
	exports.setLogLevel = _actions.setLogLevel;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _constants = __webpack_require__(1);

	var initialState = {
	  events: new Map(),
	  logLevel: 0
	};

	var reactReduxEventReducer = function reactReduxEventReducer() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	  var action = arguments[1];

	  switch (action.type) {
	    case _constants.ADD_EVENT_LISTENER:
	      return addEventListener(state, action);
	    case _constants.DISPATCH_EVENT:
	      return dispatchEvent(state, action);
	    case _constants.REMOVE_EVENT_LISTENER:
	      return removeEventListener(state, action);
	    case _constants.REMOVE_ALL_LISTENERS_FOR_EVENT:
	      return removeAllListenersForEvent(state, action);
	    case _constants.REMOVE_ALL_LISTENERS_FOR_CONTEXT:
	      return removeAllListenersForContext(state, action);
	    case _constants.SET_LOGLEVEL:
	      return setLogLevel(state, action);
	    default:
	      return state;
	  }
	};

	function dispatchEvent(state, action) {
	  var eventName = action.event.name;
	  var payload = action.event.payload;
	  var priority = action.event.priority;

	  log(state.logLevel, 2, 'Dispatch Event received. Name: [' + eventName + '], Priority: [' + priority + ']');
	  if (!state.events.has(eventName)) {
	    log(state.logLevel, 1, 'Warning: Dispatched event [' + eventName + '], but no listeners exist.');
	    return state;
	  }
	  var eventListeners = state.events.get(eventName);
	  var listenersToHandle = [];

	  // Create a list of all listeners that are eligeable to handle
	  // the event based on their priority setting
	  eventListeners.forEach(function (listeners) {
	    listeners.forEach(function (listenerData) {
	      if (listenerData.priority >= priority) {
	        listenersToHandle.push(listenerData);
	      }
	    });
	  });

	  // Sort listeners by priority and handle in order
	  if (listenersToHandle.length > 0) {
	    listenersToHandle.sort(function (a, b) {
	      var ap = a.priority;
	      var bp = b.priority;
	      return ap > bp ? -1 : ap < bp ? 1 : 0;
	    });
	    listenersToHandle.forEach(function (listenerData) {
	      listenerData.handler.apply(listenerData.context, [{
	        type: eventName,
	        context: listenerData.context,
	        priority: priority,
	        payload: payload
	      }]);
	    });
	  } else {
	    log(state.logLevel, 1, 'Warning: No handlers for [' + eventName + '] at or higher than priority level [' + priority + ']!');
	  }

	  return state;
	}

	function addEventListener(state, action) {
	  log(state.logLevel, 2, 'Add Event Listener:', action);
	  var eventName = action.name;
	  var listenerContext = action.context;
	  var listenerHandler = action.handler;
	  var listenerPriority = action.priority;

	  if (typeof listenerHandler !== 'function') {
	    log(state.logLevel, 0, 'Error: Tried to add a listener for event [' + eventName + '] but the provided handler is not a function!');
	    return state;
	  }

	  if (!state.events.has(eventName)) {
	    state.events.set(eventName, new Map());
	  }
	  var eventListeners = state.events.get(eventName);

	  if (!eventListeners.has(listenerContext)) {
	    eventListeners.set(listenerContext, new Map());
	  }
	  var listenersInContext = eventListeners.get(listenerContext);

	  listenersInContext.forEach(function (key, listener) {
	    if (key === listenerHandler) {
	      log(state.logLevel, 1, 'Warning: Duplicate. Handler for event [' + eventName + '] already exists, set at priority level: [' + listener.priority + ']! Not adding a duplicate.');
	      return state;
	    }
	  });

	  // Adding the listener
	  listenersInContext.set(listenerHandler, {
	    priority: listenerPriority,
	    context: listenerContext,
	    handler: listenerHandler
	  });

	  return state;
	}

	function removeEventListener(state, action) {
	  log(state.logLevel, 2, 'Remove Event Listener', action);
	  var eventName = action.name;
	  var listenerContext = action.context;
	  var listenerHandler = action.handler;

	  var events = state.events.get(eventName);
	  if (events === undefined) {
	    log(state.logLevel, 1, 'Warning: Tried to remove a listener for event [' + eventName + '], but no listeners for that event exist.');
	    return state;
	  }

	  var listeners = events.get(listenerContext);
	  if (listeners === undefined) {
	    log(state.logLevel, 1, 'Warning: Tried to remove a listener for event [' + eventName + '], but none exist.');
	    return state;
	  }

	  var found = listeners['delete'](listenerHandler);
	  if (!found) {
	    log(state.logLevel, 1, 'Warning: Tried to remove a listener for event [' + eventName + '], but didn\'t find a listener that matches.');
	  } else {
	    // If no handlers exist for the context, delete the empty map.
	    if (events.get(listenerContext).size === 0) {
	      events['delete'](listenerContext);
	      if (state.events.get(eventName).size === 0) {
	        state.events['delete'](eventName);
	      }
	    }
	  }

	  return state;
	}

	function removeAllListenersForContext(state, action) {
	  log(state.logLevel, 2, 'Remove Event Listeners For Context', action);
	  var listenerContext = action.context;
	  var events = state.events;
	  var found = false;
	  events.forEach(function (eventListeners, eventType, eventMap) {
	    if (eventListeners['delete'](listenerContext)) {
	      found = true;
	      if (eventMap.size === 0) {
	        eventMap['delete'](eventType);
	      }
	    }
	  });
	  if (!found) {
	    log(state.logLevel, 1, 'Warning: Tried to remove listeners for context [' + listenerContext + '], but didn\'t find any.');
	  }

	  return state;
	}

	function removeAllListenersForEvent(state, action) {
	  log(state.logLevel, 2, 'Remove Event Listeners For Event', action);
	  var eventName = action.name;
	  if (!state.events['delete'](eventName)) {
	    log(state.logLevel, 1, 'Warning: Tried to remove listeners for event [' + eventName + '], but none exist.');
	  }
	  return state;
	}

	function setLogLevel(state, action) {
	  log(state.logLevel, 2, 'setLogLevel', action);
	  if (typeof action.level !== 'number') {
	    log(state.logLevel, 0, 'Error: Tried to set Logging Level, but value is not a number: [' + action.level + ']');
	    return state;
	  }
	  var newLevel = parseInt(action.level, 10);
	  log(state.logLevel, 1, 'Changing loglevel to', newLevel);
	  return Object.assign({}, state, {
	    logLevel: newLevel
	  });
	}

	function log(logLevel, targetLevel, msg) {
	  var _console;

	  for (var _len = arguments.length, rest = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
	    rest[_key - 3] = arguments[_key];
	  }

	  if (logLevel >= targetLevel) (_console = console).log.apply(_console, ['ReactReduxEventReducer >', msg].concat(rest));
	}

	exports['default'] = reactReduxEventReducer;

/***/ })
/******/ ])
});
;