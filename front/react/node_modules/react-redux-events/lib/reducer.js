'use strict';

exports.__esModule = true;

var _constants = require('./constants');

var initialState = {
  events: new Map(),
  logLevel: 0
};

var reactReduxEventReducer = function reactReduxEventReducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments[1];

  switch (action.type) {
    case _constants.ADD_EVENT_LISTENER:
      return addEventListener(state, action);
    case _constants.DISPATCH_EVENT:
      return dispatchEvent(state, action);
    case _constants.REMOVE_EVENT_LISTENER:
      return removeEventListener(state, action);
    case _constants.REMOVE_ALL_LISTENERS_FOR_EVENT:
      return removeAllListenersForEvent(state, action);
    case _constants.REMOVE_ALL_LISTENERS_FOR_CONTEXT:
      return removeAllListenersForContext(state, action);
    case _constants.SET_LOGLEVEL:
      return setLogLevel(state, action);
    default:
      return state;
  }
};

function dispatchEvent(state, action) {
  var eventName = action.event.name;
  var payload = action.event.payload;
  var priority = action.event.priority;

  log(state.logLevel, 2, 'Dispatch Event received. Name: [' + eventName + '], Priority: [' + priority + ']');
  if (!state.events.has(eventName)) {
    log(state.logLevel, 1, 'Warning: Dispatched event [' + eventName + '], but no listeners exist.');
    return state;
  }
  var eventListeners = state.events.get(eventName);
  var listenersToHandle = [];

  // Create a list of all listeners that are eligeable to handle
  // the event based on their priority setting
  eventListeners.forEach(function (listeners) {
    listeners.forEach(function (listenerData) {
      if (listenerData.priority >= priority) {
        listenersToHandle.push(listenerData);
      }
    });
  });

  // Sort listeners by priority and handle in order
  if (listenersToHandle.length > 0) {
    listenersToHandle.sort(function (a, b) {
      var ap = a.priority;
      var bp = b.priority;
      return ap > bp ? -1 : ap < bp ? 1 : 0;
    });
    listenersToHandle.forEach(function (listenerData) {
      listenerData.handler.apply(listenerData.context, [{
        type: eventName,
        context: listenerData.context,
        priority: priority,
        payload: payload
      }]);
    });
  } else {
    log(state.logLevel, 1, 'Warning: No handlers for [' + eventName + '] at or higher than priority level [' + priority + ']!');
  }

  return state;
}

function addEventListener(state, action) {
  log(state.logLevel, 2, 'Add Event Listener:', action);
  var eventName = action.name;
  var listenerContext = action.context;
  var listenerHandler = action.handler;
  var listenerPriority = action.priority;

  if (typeof listenerHandler !== 'function') {
    log(state.logLevel, 0, 'Error: Tried to add a listener for event [' + eventName + '] but the provided handler is not a function!');
    return state;
  }

  if (!state.events.has(eventName)) {
    state.events.set(eventName, new Map());
  }
  var eventListeners = state.events.get(eventName);

  if (!eventListeners.has(listenerContext)) {
    eventListeners.set(listenerContext, new Map());
  }
  var listenersInContext = eventListeners.get(listenerContext);

  listenersInContext.forEach(function (key, listener) {
    if (key === listenerHandler) {
      log(state.logLevel, 1, 'Warning: Duplicate. Handler for event [' + eventName + '] already exists, set at priority level: [' + listener.priority + ']! Not adding a duplicate.');
      return state;
    }
  });

  // Adding the listener
  listenersInContext.set(listenerHandler, {
    priority: listenerPriority,
    context: listenerContext,
    handler: listenerHandler
  });

  return state;
}

function removeEventListener(state, action) {
  log(state.logLevel, 2, 'Remove Event Listener', action);
  var eventName = action.name;
  var listenerContext = action.context;
  var listenerHandler = action.handler;

  var events = state.events.get(eventName);
  if (events === undefined) {
    log(state.logLevel, 1, 'Warning: Tried to remove a listener for event [' + eventName + '], but no listeners for that event exist.');
    return state;
  }

  var listeners = events.get(listenerContext);
  if (listeners === undefined) {
    log(state.logLevel, 1, 'Warning: Tried to remove a listener for event [' + eventName + '], but none exist.');
    return state;
  }

  var found = listeners['delete'](listenerHandler);
  if (!found) {
    log(state.logLevel, 1, 'Warning: Tried to remove a listener for event [' + eventName + '], but didn\'t find a listener that matches.');
  } else {
    // If no handlers exist for the context, delete the empty map.
    if (events.get(listenerContext).size === 0) {
      events['delete'](listenerContext);
      if (state.events.get(eventName).size === 0) {
        state.events['delete'](eventName);
      }
    }
  }

  return state;
}

function removeAllListenersForContext(state, action) {
  log(state.logLevel, 2, 'Remove Event Listeners For Context', action);
  var listenerContext = action.context;
  var events = state.events;
  var found = false;
  events.forEach(function (eventListeners, eventType, eventMap) {
    if (eventListeners['delete'](listenerContext)) {
      found = true;
      if (eventMap.size === 0) {
        eventMap['delete'](eventType);
      }
    }
  });
  if (!found) {
    log(state.logLevel, 1, 'Warning: Tried to remove listeners for context [' + listenerContext + '], but didn\'t find any.');
  }

  return state;
}

function removeAllListenersForEvent(state, action) {
  log(state.logLevel, 2, 'Remove Event Listeners For Event', action);
  var eventName = action.name;
  if (!state.events['delete'](eventName)) {
    log(state.logLevel, 1, 'Warning: Tried to remove listeners for event [' + eventName + '], but none exist.');
  }
  return state;
}

function setLogLevel(state, action) {
  log(state.logLevel, 2, 'setLogLevel', action);
  if (typeof action.level !== 'number') {
    log(state.logLevel, 0, 'Error: Tried to set Logging Level, but value is not a number: [' + action.level + ']');
    return state;
  }
  var newLevel = parseInt(action.level, 10);
  log(state.logLevel, 1, 'Changing loglevel to', newLevel);
  return Object.assign({}, state, {
    logLevel: newLevel
  });
}

function log(logLevel, targetLevel, msg) {
  var _console;

  for (var _len = arguments.length, rest = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    rest[_key - 3] = arguments[_key];
  }

  if (logLevel >= targetLevel) (_console = console).log.apply(_console, ['ReactReduxEventReducer >', msg].concat(rest));
}

exports['default'] = reactReduxEventReducer;